#import "@preview/codelst:2.0.2": sourcecode, sourcefile
#import "@preview/cetz:0.3.1"
#import "@preview/cetz-plot:0.1.0": plot, chart

== 発展課題1

=== 実装の方針

動的計画法を用いてナップサック問題を解き、選択された荷物を復元する機能を持つ `knapsackDP2` 関数を実装する。

1. *DPテーブルの作成:*  
   - `G[i][j]`: `i` 番目までの荷物から重さ `j` 以下で得られる最大価値。  
   - `S[i][j]`: `i` 番目の荷物が選ばれたかどうかを示す真偽値。  

2. *状態遷移:*  
   - 重さ制約を満たす場合、`i` 番目の荷物を含めるかどうかを選択。
   - `G[i][j] = max(G[i - 1][j], G[i - 1][j - w[i]] + v[i])`
     - 荷物を含める場合には `S[i][j] = true`
     - 含めない場合には `S[i][j] = false`

3. *部分集合の復元:*  
   - DPテーブル `S` を使い、選択された荷物を後ろから順に復元する。  
   - `rC` は残りの容量。`S[i][rC]` が真であればその荷物を選び、容量を更新する。

=== 実装コード及びその説明

実装した `knapsackDP2.c` を @code3-1 に示す。

#show figure: set block(breakable: true)

#figure(
  sourcefile(read("./knapsackDP2.c"), file:"./knapsackDP2.c"),
  caption: [発展課題 1 の実装コード],
) <code3-1>

このコードは実装の方針で述べたものの通りに実装している。

以下に主要部分の説明を述べる。

1. *DPテーブル G と S を構築するループ*

#sourcecode(numbers-start: 45)[```c
for (int i = 0; i <= n; i++) {
    for (int j = 0; j <= C; j++) {
        if (i == 0 || j == 0) {
            G[i][j] = 0;
            S[i][j] = false;
        } else if (j >= w[i]) {
            const int include = G[i - 1][j - w[i]] + v[i];
            const int exclude = G[i - 1][j];
            if (include > exclude) {
                G[i][j] = include;
                S[i][j] = true;
            } else {
                G[i][j] = exclude;
                S[i][j] = false;
            }
        } else {
            G[i][j] = G[i - 1][j];
            S[i][j] = false;
        }
    }
}
```]

- `include > exclude` の場合に荷物を選択し、`S[i][j] = true` にする。

2. *選択された荷物を復元するループ*

#sourcecode(numbers-start: 68)[```c
int rC = C;
for (int i = n; i >= 0; i--) {
    if (S[i][rC]) {
        SS[i] = true;
        rC -= w[i];
    } else {
        SS[i] = false;
    }
}
```]

3. メモリの解放

#sourcecode(numbers-start: 78)[```c
free(G[0]);
free(G);
free(S[0]);
free(S);
```]

`makeIntMatrix` や `makeBoolMatrix` で得られる配列は内部のメモリは連続しているため、`0` 番目を free すればよいと考え、そのように実装している。

また、`knapsackDP2Main.c` において `knapsackDP2` の結果を保持している変数 `S` のメモリ解放処理が無かったため、
`printf("合計価値 %d\n", total);` の行の後ろに `free(S);` を入れた。（もっともこの後にプロセスがすぐ死ぬので不要ではあるが、一般的には適切でないと考えられることが多いため）

=== 実行結果

`make` コマンドを用いて適切にコンパイルしたのち、@code3-2 の通り実行を行った。また結果も示している。

#figure(
  sourcecode[```
  $ make knapsackDP2
  cc    -c -o knapsackDP2.o knapsackDP2.c
  cc    -c -o knapsackDP2Main.o knapsackDP2Main.c
  cc   knapsackDP2.o knapsackDP2Main.o   -o knapsackDP2

  $ ./knapsackDP2 4 5
  重さ 2 価値 380
  重さ 3 価値 520
  合計価値 900

  $
  ```],
  caption: "実行結果"
) <code3-2>

=== 発展課題1.1

本課題は、教科書の表 6.1の例に関して，荷物の数が4, 容量が3,4,5の場合の実行結果が正しいことを確認するというものである。

実行結果を @code3-3 に示す。

#figure(
  sourcecode[```
  $ ./knapsackDP2 4 3  
  重さ 1 価値 250
  重さ 2 価値 380
  合計価値 630

  $ ./knapsackDP2 4 4
  重さ 1 価値 250
  重さ 3 価値 520
  合計価値 770

  $ ./knapsackDP2 4 5
  重さ 2 価値 380
  重さ 3 価値 520
  合計価値 900

  $
  ```],
  caption: "教科書の表 6.1の例に関して、荷物の数が4、容量が3,4,5の場合の実行結果"
) <code3-3>

実行結果が正しいことを確認する。
なお、具体的な確認方法については Appendix を参照。

/ 容量が 3 の場合:
  
  - 1 番目の荷物（重さ 1, 価値 250）
  - 2 番目の荷物（重さ 2, 価値 380）

  を選ぶとき価値の合計は 630 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。
  
/ 容量が 4 の場合:
  
  - 1 番目の荷物（重さ 1, 価値 250）
  - 4 番目の荷物（重さ 4, 価値 520）

  を選ぶとき価値の合計は 770 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。

/ 容量が 5 の場合:
  
  - 2 番目の荷物（重さ 1, 価値 380）
  - 4 番目の荷物（重さ 4, 価値 520）

  を選ぶとき価値の合計は 900 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。

以上より、本課題の要件を確認することができた。

=== 発展課題1.2

`knapsackDP2Main.c` 内の `num` と `v[]`, `w[]` の定義を以下のように変更した。

#sourcecode[```c
int num = 10;
int v[] = {0, 39, 20, 14, 56, 24, 25, 200, 20, 10, 8};
int w[] = {0, 1, 2, 4, 500, 20, 12, 23, 20, 10, 2};
```]

また、プログラムの動作を確認すると @code3-4 のようになった。

#figure(
  sourcecode[```
$ ./knapsackDP2 10 10
重さ 1 価値 39
重さ 2 価値 20
重さ 4 価値 14
重さ 2 価値 8
合計価値 81

$ ./knapsackDP2 10 12
重さ 1 価値 39
重さ 2 価値 20
重さ 4 価値 14
重さ 2 価値 8
合計価値 81

$ ./knapsackDP2 10 15
重さ 1 価値 39
重さ 2 価値 20
重さ 12 価値 25
合計価値 84

$ ./knapsackDP2 10 1 
重さ 1 価値 39
合計価値 39

$ ./knapsackDP2 10 100
重さ 1 価値 39
重さ 2 価値 20
重さ 4 価値 14
重さ 20 価値 24
重さ 12 価値 25
重さ 23 価値 200
重さ 20 価値 20
重さ 10 価値 10
重さ 2 価値 8
合計価値 360

$
  ```],
  caption: "実行結果"
) <code3-4>

つぎに、`knapsackDP2Main.c` 内の `num` と `v[]`, `w[]` の定義を以下のように変更した。

#sourcecode[```c
int num = 10;
int v[] = {0, 1, 2, 6, 2, 5, 2, 6, 2, 9, 1};
int w[] = {0, 1, 5, 8, 2, 6, 2, 8, 9, 9, 3};
```]

また、プログラムの動作を確認すると @code3-5 のようになった。

#figure(
  sourcecode[```
$ ./knapsackDP2 10 4
重さ 2 価値 2
重さ 2 価値 2
合計価値 4

$ ./knapsackDP2 10 59
重さ 1 価値 1
重さ 5 価値 2
重さ 8 価値 6
重さ 2 価値 2
重さ 6 価値 5
重さ 2 価値 2
重さ 8 価値 6
重さ 9 価値 2
重さ 9 価値 9
重さ 3 価値 1
合計価値 36

$ ./knapsackDP2 10 9 
重さ 9 価値 9
合計価値 9

$ ./knapsackDP2 10 14
重さ 1 価値 1
重さ 2 価値 2
重さ 2 価値 2
重さ 9 価値 9
合計価値 14

$ ./knapsackDP2 10 15
重さ 6 価値 5
重さ 9 価値 9
合計価値 14

$ ./knapsackDP2 10 3 
重さ 1 価値 1
重さ 2 価値 2
合計価値 3

$ ./knapsackDP2 10 0
合計価値 0

$
  ```],
  caption: "実行結果"
) <code3-5>

つぎに、`knapsackDP2Main.c` 内の `num` と `v[]`, `w[]` の定義を以下のように変更した。

#sourcecode[```c
int num = 10;
int v[] = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int w[] = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
```]

また、プログラムの動作を確認すると @code3-6 のようになった。

#figure(
  sourcecode[```
$ ./knapsackDP2 10 1  
重さ 1 価値 1
合計価値 1

$ ./knapsackDP2 10 2  
重さ 1 価値 1
重さ 1 価値 1
合計価値 2

$ ./knapsackDP2 10 8  
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
合計価値 8

$ ./knapsackDP2 10 9
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
合計価値 9

$ ./knapsackDP2 10 10 
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
合計価値 10

$ ./knapsackDP2 10 10000
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
重さ 1 価値 1
合計価値 10

$ ./knapsackDP2 10 0    
合計価値 0

$
  ```],
  caption: "実行結果"
) <code3-6>

=== 考察

動的計画法の復元は、DP テーブルを逆順に見ていけばよいと考えられる。
今回は `bool` 型の配列でどれを使ったかを持っているが、どこから来たのかという情報だけを持ても復元することができると考えられる。（結局差分は `w` 由来であるため。）

さらに複雑な動的計画法でも、操作の情報を持っておけば、逆順に見ていき復元ができる。
