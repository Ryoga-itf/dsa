#import "@preview/codelst:2.0.2": sourcecode, sourcefile
#import "@preview/cetz:0.3.1"
#import "@preview/cetz-plot:0.1.0": plot, chart

== 基本課題2

=== 実装の方針

$"dp"[x][y] := x "番目までの荷物の中から重さが" y "を超えないように選んだときの、価値の総和の最大値"$

とすると、以下の手順により $"dp"[x - 1][y]$ からこの値は求めることができるから、動的計画法を用いて解くことができる。

- $x = 0$ または $y = 0$ であるとき、$"dp"[x][y] = 0$
- 品物 ($w[x], v[x]$) を選ぶ場合 ($y >= w[x]$ の場合に限る)
  - $"dp"[x][y] = "dp"[x - 1][y - w[x]] + v[x]$
- 品物 ($w[x], v[x]$) を選ばない場合
  - $"dp"[x][y] = "dp"[x - 1][y]$

と更新できる。
$"dp"$ は価値の総和の最大値であるから、これらの操作のうち大きい方を取っていくように更新していけばよい。 

=== 実装コード及びその説明

実装した `knapsackDP.c` を @code2-1 に示す。

なお、VLA が使える環境ではあるが `knapsackMain.c` に倣って `malloc` 及び `free` を読んでいるため、メモリの動的確保及び解放が煩雑になっている。
メモリにおいては内部で連続するようにアロケーションする実装にしたため、`free(dp[0])` のように先頭番地を free するだけで十分である。

また、`max` マクロは参考実装で与えられたものをそのまま利用している。

#figure(
  sourcefile(read("./knapsackDP.c"), file:"./knapsackDP.c"),
  caption: [基本課題 2 の実装コード],
) <code2-1>

このコードは実装の方針で述べたものの通りに実装している。

以下に主要部分の説明を述べる。

1. *メモリ確保*

#sourcecode(numbers-start: 12)[```c
int **dp = (int **)malloc(sizeof(int *) * (k + 1));
int *array = (int *)malloc(sizeof(int) * (k + 1) * (i + 1));
for (int index = 0; index <= k; index++) {
    dp[index] = array + (i + 1) * index;
}
```]

- `dp` は動的に確保された二次元配列。
- `dp[x][y]` は荷物 `x` 個を使い、容量 `y` のナップサックで得られる最大価値を表す。
- 一度だけメモリを確保し、行ごとにポインタを設定することでメモリ効率を向上させている。

2. *DPテーブルの計算*

#sourcecode(numbers-start: 18)[```c
for (int x = 0; x <= k; x++) {
    for (int y = 0; y <= i; y++) {
        if (x == 0 || y == 0) {
            dp[x][y] = 0;
        } else if (y >= w[x]) {
            dp[x][y] = max(dp[x - 1][y - w[x]] + v[x], dp[x - 1][y]);
        } else {
            dp[x][y] = dp[x - 1][y];
        }
    }
}
```]

- 初期条件: `dp[0][y] = 0` または `dp[x][0] = 0` では価値はゼロ。
- 荷物がナップサック容量に収まる場合、`max(dp[x - 1][y - w[x]] + v[x], dp[x - 1][y])` の最大値を選ぶ。
- 荷物が容量を超える場合、`dp[x][y] = dp[x - 1][y]` を選択する。

3. *結果取得とメモリ解放*

#sourcecode(numbers-start: 30)[```c
int result = dp[k][i];

free(dp[0]);
free(dp);
```]

- 計算結果を `result` に保存し、確保したメモリを解放する。

=== 実行結果

`make` コマンドを用いて適切にコンパイルしたのち、@code2-2 の通り実行を行った。また結果も示している。

#figure(
  sourcecode[```
  $ make knapsackDP
  cc    -c -o knapsackDP.o knapsackDP.c
  cc   knapsackDP.o knapsackDPMain.o   -o knapsackDP

  $ ./knapsackDP 4 4 
  結果：770

  $ ./knapsackDP 5  
  容量：25
  結果：345
  実行時間：0.000005 sec.

  $
  ```],
  caption: "実行結果"
) <code2-2>

=== 基本課題 2.1

本課題は、教科書の表 6.1の例に関して，荷物の数が4, 容量が3,4,5の場合の実行結果が正しいことを確認するというものである。

実行結果を @code2-3 に示す。

#figure(
  sourcecode[```
  $ ./knapsackDP 4 3     
  結果：630

  $ ./knapsackDP 4 4
  結果：770

  $ ./knapsackDP 4 5
  結果：900

  $
  ```],
  caption: "教科書の表 6.1の例に関して、荷物の数が4、容量が3,4,5の場合の実行結果"
) <code2-3>

実行結果が正しいことを確認する。
なお、具体的な確認方法については Appendix を参照。

/ 容量が 3 の場合:
  
  - 1 番目の荷物（重さ 1, 価値 250）
  - 2 番目の荷物（重さ 2, 価値 380）

  を選ぶとき価値の合計は 630 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。
  
/ 容量が 4 の場合:
  
  - 1 番目の荷物（重さ 1, 価値 250）
  - 4 番目の荷物（重さ 4, 価値 520）

  を選ぶとき価値の合計は 770 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。

/ 容量が 5 の場合:
  
  - 2 番目の荷物（重さ 1, 価値 380）
  - 4 番目の荷物（重さ 4, 価値 520）

  を選ぶとき価値の合計は 900 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。

以上より、本課題の要件を確認することができた。

=== 基本課題 2.2

本課題は、動的計画法を用いない実装よりも遥かに大きな問題を解けることを確認するものである。

実行結果を @code2-4 に示す。

#figure(
  sourcecode[```
  $ ./knapsackDP 30   
  容量：150
  結果：1675
  実行時間：0.000059 sec.

  $ ./knapsackDP 300  
  容量：1500
  結果：15196
  実行時間：0.005406 sec.

  $ ./knapsackDP 3000 
  容量：15000
  結果：147576
  実行時間：0.205102 sec.

  $ ./knapsackDP 5000
  容量：25000
  結果：249279
  実行時間：0.508030 sec.

  $ ./knapsackDP 10000
  容量：50000
  結果：500697
  実行時間：1.945831 sec.
  ```],
  caption: "大きな問題が解けることの確認"
) <code2-4>

また、コードを観察すると `knapsackDP` 関数の時間計算量は $Omicron(k dot i)$ であることがわかる。
すなわち、対象とする荷物の数とナップサックの容量の積が大きければ大きいほど実行時間は大きくなる。

これを確認するために、`knapsackDPMain.c` の `argc == 2` の場合の容量を `n * 5` ではなく固定値にして実行時間を比較した。

結果を @table2 に示す。

#let data_100 = (
  (100, 0.000164),
  (500, 0.000691),
  (1000, 0.001576),
  (5000, 0.006114),
  (10000, 0.012020),
  (50000, 0.022866),
  (100000, 0.042118),
)
#let data_500 = (
  (100, 0.000845),
  (500, 0.004095),
  (1000, 0.007937),
  (5000, 0.019544),
  (10000, 0.043070),
  (50000, 0.115798),
  (100000, 0.221380)
)
#let data_1000 = (
  (100, 0.001750),
  (500, 0.006925),
  (1000, 0.014822),
  (5000, 0.027210),
  (10000, 0.059142),
  (50000, 0.218849),
  (100000, 0.416289),
)

#figure(
  table(
    columns: (auto, auto, auto, auto),
    inset: 7pt,
    align: center,
    table.header(
      [*$n$*], [*$i = 100$*], [*$i = 500$*], [*$i = 1000$*]
    ),
    ..range(1, 7).map(t=> (
      data_100.at(t).at(0),
      data_100.at(t).at(1),
      data_500.at(t).at(1),
      data_1000.at(t).at(1),
    )).flatten().map(v => $#v$)
  ),
  caption: [実行時間の比較]
) <table2>

これをグラフにプロットすると @fig2 のようになった。
なお、$i = 100$ は青の実線、$i = 500$ は赤の実線、$i = 1000$ は緑の実線で示している。

#figure(
  cetz.canvas({
    plot.plot(
      size: (15, 9),
      x-label: [$N$],
      x-min: 0,
      x-max: 100000,
      x-grid: "major",
      y-tick-step: 0.1,
      y-label: [実行時間 (秒)],
      y-max: 0.5,
      y-min: 0,
      y-grid: "major",
      {
        plot.add(data_100)
        plot.add(data_500)
        plot.add(data_1000)
      },
    )
  }),
  caption: [@table2 をグラフにプロットした様子]
) <fig2>

概ね $i$ が $2$ 倍になると実行時間も $2$ 倍に、また $n$ が $2$ になると同様に実行時間が $2$ 倍になることがわかる。
$i$ も $k$ も $2$ 倍になると、実行時間は $4$ 倍となり、時間計算量は $Omicron(k dot i)$ であると推測することができる。

=== 考察

再帰関数を実装するより非常に効率的である。
しかし、実装難易度は再帰関数のそれよりも高い。
