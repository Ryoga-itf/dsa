#import "@preview/codelst:2.0.2": sourcecode, sourcefile
#import "@preview/cetz:0.3.1"
#import "@preview/cetz-plot:0.1.0": plot, chart

== 基本課題2

=== 実装の方針

$"dp"[x][y] := x "番目までの荷物の中から重さが" y "を超えないように選んだときの、価値の総和の最大値"$

とすると、以下の手順により $"dp"[x - 1][y]$ からこの値は求めることができるから、動的計画法を用いて解くことができる。

- $x = 0$ または $y = 0$ であるとき、$"dp"[x][y] = 0$
- 品物 ($w[x], v[x]$) を選ぶ場合 ($y >= w[x]$ の場合に限る)
  - $"dp"[x][y] = "dp"[x - 1][y - w[x]] + v[x]$
- 品物 ($w[x], v[x]$) を選ばない場合
  - $"dp"[x][y] = "dp"[x - 1][y]$

と更新できる。
$"dp"$ は価値の総和の最大値であるから、これらの操作のうち大きい方を取っていくように更新していけばよい。 

=== 実装コード及びその説明

実装した `knapsackDP.c` を @code2-1 に示す。

なお、VLA が使える環境ではあるが `knapsackMain.c` に倣って `malloc` 及び `free` を読んでいるため、メモリの動的確保及び解放が煩雑になっている。
メモリにおいては内部で連続するようにアロケーションする実装にしたため、`free(dp[0])` のように先頭番地を free するだけで十分である。

また、`max` マクロは参考実装で与えられたものをそのまま利用している。

#figure(
  sourcefile(read("./knapsackDP.c"), file:"./knapsackDP.c"),
  caption: [基本課題 2 の実装コード],
) <code2-1>

このコードは実装の方針で述べたものの通りに実装している。

以下に主要部分の説明を述べる。

1. *メモリ確保*

#sourcecode(numbers-start: 12)[```c
int **dp = (int **)malloc(sizeof(int *) * (k + 1));
int *array = (int *)malloc(sizeof(int) * (k + 1) * (i + 1));
for (int index = 0; index <= k; index++) {
    dp[index] = array + (i + 1) * index;
}
```]

- `dp` は動的に確保された二次元配列。
- `dp[x][y]` は荷物 `x` 個を使い、容量 `y` のナップサックで得られる最大価値を表す。
- 一度だけメモリを確保し、行ごとにポインタを設定することでメモリ効率を向上させている。

2. *DPテーブルの計算*

#sourcecode(numbers-start: 18)[```c
for (int x = 0; x <= k; x++) {
    for (int y = 0; y <= i; y++) {
        if (x == 0 || y == 0) {
            dp[x][y] = 0;
        } else if (y >= w[x]) {
            dp[x][y] = max(dp[x - 1][y - w[x]] + v[x], dp[x - 1][y]);
        } else {
            dp[x][y] = dp[x - 1][y];
        }
    }
}
```]

- 初期条件: `dp[0][y] = 0` または `dp[x][0] = 0` では価値はゼロ。
- 荷物がナップサック容量に収まる場合、`max(dp[x - 1][y - w[x]] + v[x], dp[x - 1][y])` の最大値を選ぶ。
- 荷物が容量を超える場合、`dp[x][y] = dp[x - 1][y]` を選択する。

3. *結果取得とメモリ解放*

#sourcecode(numbers-start: 30)[```c
int result = dp[k][i];

free(dp[0]);
free(dp);
```]

- 計算結果を `result` に保存し、確保したメモリを解放する。

=== 実行結果

`make` コマンドを用いて適切にコンパイルしたのち、@code2-2 の通り実行を行った。また結果も示している。

#figure(
  sourcecode[```
  $ make knapsackDP
  cc    -c -o knapsackDP.o knapsackDP.c
  cc   knapsackDP.o knapsackDPMain.o   -o knapsackDP

  $ ./knapsackDP 4 4 
  結果：770

  $ ./knapsackDP 5  
  容量：25
  結果：345
  実行時間：0.000005 sec.

  $
  ```],
  caption: "実行結果"
) <code2-2>

=== 基本課題 2.1

本課題は、教科書の表 6.1の例に関して，荷物の数が4, 容量が3,4,5の場合の実行結果が正しいことを確認するというものである。

実行結果を @code2-3 に示す。

#figure(
  sourcecode[```
  $ ./knapsackDP 4 3     
  結果：630

  $ ./knapsackDP 4 4
  結果：770

  $ ./knapsackDP 4 5
  結果：900

  $
  ```],
  caption: "教科書の表 6.1の例に関して、荷物の数が4、容量が3,4,5の場合の実行結果"
) <code2-3>

実行結果が正しいことを確認する。
なお、具体的な確認方法については Appendix を参照。

/ 容量が 3 の場合:
  
  - 1 番目の荷物（重さ 1, 価値 250）
  - 2 番目の荷物（重さ 2, 価値 380）

  を選ぶとき価値の合計は 630 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。
  
/ 容量が 4 の場合:
  
  - 1 番目の荷物（重さ 1, 価値 250）
  - 4 番目の荷物（重さ 4, 価値 520）

  を選ぶとき価値の合計は 770 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。

/ 容量が 5 の場合:
  
  - 2 番目の荷物（重さ 1, 価値 380）
  - 4 番目の荷物（重さ 4, 価値 520）

  を選ぶとき価値の合計は 900 と最大となり、これ以外に価値の合計を大きくする組合せはない。
  実行結果として得られた値は正しい。

以上より、本課題の要件を確認することができた。

=== 基本課題 2.2

// TODO:

=== 考察

// TODO:
